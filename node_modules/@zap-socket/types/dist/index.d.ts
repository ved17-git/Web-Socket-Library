import { z } from 'zod';
export type ZapServerType<T extends EventMap> = {
    sendMessageRaw: (clientId: string, data: any) => void;
    event: {
        [K in keyof T as T[K] extends (ZapServerEvent<any> | ZapEvent<any, any>) ? K : never]: {
            send: (clientId: string, data?: (T[K] extends ZapServerEvent<any> ? T[K]["data"] : T[K] extends ZapEvent<any, any> ? ReturnType<T[K]["process"]> : never)) => void;
        };
    };
};
export type Context = {
    server: any;
    id: string;
    buffer: MiddlwareContext;
};
export type MiddlwareContext = Record<string, any>;
export type MiddlewareMetadata = {
    id: string;
    ip: string;
    timestamp: number;
    size: number;
};
export type MiddlwareMsg = {
    event: string;
    data: any;
    metadata: MiddlewareMetadata;
};
export type MiddlewareType = (ctx: MiddlwareContext, msg: MiddlwareMsg) => boolean | Promise<boolean>;
export type EventInput = z.ZodTypeAny | undefined;
export type ZapEvent<T extends EventInput, R = any, E = any> = T extends z.ZodTypeAny ? {
    input: T;
    middleware?: MiddlewareType[];
    process: (input: z.infer<T>, ctx: Context) => R;
    emitType?: E;
} : {
    input: z.ZodVoid;
    middleware?: MiddlewareType[];
    process: (ctx: Context) => R;
    emitType?: E;
};
export type ZapStream<T extends EventInput, R> = T extends z.ZodTypeAny ? {
    input: T;
    middleware?: MiddlewareType[];
    process: (input: z.infer<T>, ctx: Context) => AsyncGenerator<R, void, unknown>;
} : {
    input: z.ZodVoid;
    middleware?: MiddlewareType[];
    process: (ctx: Context) => AsyncGenerator<R, void, unknown>;
};
export type ZapServerEvent<T extends z.ZodTypeAny> = {
    data: z.infer<T>;
};
export type EventMap = Record<string, ZapEvent<any, any> | ZapServerEvent<any> | ZapStream<any, any>>;
