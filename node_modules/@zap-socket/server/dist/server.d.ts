import { WebSocketServer, WebSocket } from "ws";
import type { EventMap, ZapEvent, ZapServerEvent } from "@zap-socket/types";
import { ZodType, z } from "zod";
type CorsOptions = {
    origin: string[];
    methods: string[];
    headers: string[];
    credentials: boolean;
};
type ZapServerConstructorT = {
    port: number;
    events?: EventMap;
    cors?: CorsOptions;
    options?: {
        heartbeatPingFrequency: number;
    };
};
type ExtractSendData<T, K extends keyof T> = T[K] extends ZapServerEvent<any> ? T[K]['data'] : T[K] extends ZapEvent<any, any> ? T[K]['emitType'] extends ZodType<any, any, any> ? z.infer<T[K]['emitType']> : ReturnType<T[K]['process']> extends undefined ? undefined : ReturnType<T[K]['process']> : never;
export declare class ZapServer<T extends EventMap> {
    wss: WebSocketServer;
    onconnect: (handler: (ctx: {
        id: string;
        ws: WebSocket;
    }) => void) => void;
    private onconnectHandler;
    private wsToId;
    private idToWs;
    private persistantContext;
    private _events;
    private heartbeatMiss;
    constructor({ port, events, options }: ZapServerConstructorT, callback?: () => void);
    private removeClient;
    private heartbeat;
    private handleMessage;
    sendMessageRaw(clientId: string, data: any): void;
    sendMessage(event: keyof T, clientId: string, data: any): void;
    broadcastRaw(data: any): void;
    broadcast(event: keyof T, data: any): void;
    selectiveBroascast(event: string, data: any, connections: string[]): void;
    get events(): { [K in keyof T as T[K] extends ZapServerEvent<any> | ZapEvent<any, any> ? K : never]: {
        send: (clientId: string, data?: ExtractSendData<T, K>) => void;
        broadcast: (data?: ExtractSendData<T, K>) => void;
    }; };
    get clients(): string[];
    get socketMap(): Map<string, WebSocket>;
}
export declare const createZapServer: <T extends EventMap>({ port, events, cors, options }: ZapServerConstructorT, callback?: () => void) => ZapServer<T>;
export {};
