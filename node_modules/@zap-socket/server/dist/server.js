import { WebSocketServer } from "ws";
import { serialize, deserialize, generateId } from "./utils.js";
const isClientEvent = (event) => {
    return "process" in event; // both zapEvent and zapStream have process in them.
};
// make the server class abstracted away
// or atleast the ws interactions
// so that we can change the backends
// with ease (ws & uWebSocket).
export class ZapServer {
    // public server: http.Server;
    wss;
    onconnect;
    onconnectHandler;
    wsToId;
    idToWs;
    persistantContext;
    _events = {};
    heartbeatMiss = new Map();
    constructor({ port, events = {}, options }, callback) {
        this.wss = new WebSocketServer({ port });
        this.wsToId = new Map();
        this.idToWs = new Map();
        this.persistantContext = new Map();
        this._events = events;
        this.onconnectHandler = () => { };
        this.onconnect = (handler) => {
            this.onconnectHandler = handler;
        };
        const seconds = options?.heartbeatPingFrequency ?? 5;
        const frequency = (Number.isFinite(seconds) && seconds > 0 ? seconds : 5) * 1000;
        setInterval(() => this.heartbeat(), frequency);
        this.wss.on("listening", () => {
            if (callback)
                callback();
        });
        this.wss.on("connection", (ws, req) => {
            ws.on("message", (message) => {
                this.handleMessage(ws, req, message);
            });
            ws.on("close", () => {
                this.removeClient(ws);
            });
            ws.on("error", (err) => {
                console.error(`WebSocket error for ${this.wsToId.get(ws)}:`, err);
            });
        });
    }
    removeClient(ws) {
        const clientId = this.wsToId.get(ws);
        if (clientId) {
            this.wsToId.delete(ws);
            this.idToWs.delete(clientId);
        }
    }
    heartbeat() {
        this.idToWs.forEach((ws, id) => {
            const misses = this.heartbeatMiss.get(id) ?? 0;
            if (misses > 2) {
                if (ws)
                    ws.close();
                this.idToWs.delete(id);
                this.heartbeatMiss.delete(id);
            }
            else {
                this.heartbeatMiss.set(id, misses + 1);
            }
        });
        this.broadcastRaw("heartbeat");
    }
    async handleMessage(ws, req, message) {
        const id = this.wsToId.get(ws);
        // setting up socket id
        if (!id && message.toString() === "OPEN") {
            const id = generateId();
            this.wsToId.set(ws, id);
            this.idToWs.set(id, ws);
            ws.send("ID " + id);
            this.onconnectHandler({
                id,
                ws
            });
            return;
        }
        else if (id && message.toString() === "heartbeat") {
            this.heartbeatMiss.set(id, 0);
        }
        const clientId = this.wsToId.get(ws);
        const parsedMessage = deserialize(message.toString());
        if (!parsedMessage)
            return;
        const { event, stream, data, requestId, streamId, batch } = parsedMessage;
        const key = event || stream;
        const eventObj = this._events[key];
        if (!eventObj || !isClientEvent(eventObj))
            return;
        // Type validation.
        const inputType = eventObj.input;
        const { success, error } = inputType.safeParse(data);
        if (!success && error) {
            // check if the message is of req-res
            if (requestId) {
            }
            return;
        }
        const { process, middleware } = eventObj;
        if (!id) {
            ws.close();
            return;
        }
        const buffer = this.persistantContext.get(id);
        const ctx = { buffer };
        if (middleware) {
            for (const m of middleware) {
                const metadata = {
                    id: clientId,
                    ip: req.socket.remoteAddress,
                    timestamp: Date.now(),
                    size: message.toString().length,
                };
                const msg = {
                    event: key,
                    data: parsedMessage,
                    metadata,
                };
                let shouldPass = m(ctx, msg);
                shouldPass = shouldPass instanceof Promise ? await shouldPass : shouldPass;
                if (!shouldPass)
                    return;
            }
        }
        // All middleware passed
        const context = { server: this, id: this.wsToId.get(ws), buffer: ctx };
        if (requestId) { // req-res premitive
            let result;
            if (batch) {
                result = data.map((part) => process(part, context));
            }
            else {
                result = process(data, context);
                if (result instanceof Promise) {
                    result = await result;
                }
            }
            if (result === undefined) { // just ACK the request process returns nothing
                ws.send("ACK " + requestId);
                return;
            }
            const serialized = serialize({ requestId, event: key, data: result });
            if (!serialized)
                return;
            ws.send(serialized);
        }
        else if (streamId) { // stream premitive
            const consumeStream = async () => {
                const result = process(data, context);
                for await (const fragment of result) {
                    this.sendMessageRaw(clientId, { streamId, fragment });
                }
                this.sendMessageRaw(clientId, { streamId, done: true });
            };
            consumeStream();
        }
    }
    sendMessageRaw(clientId, data) {
        const ws = this.idToWs.get(clientId);
        //  TODO: throw a nice error
        if (!ws)
            return;
        const serializedData = serialize(data);
        //  TODO: throw a nice error
        if (!serializedData)
            return;
        ws.send(serializedData);
    }
    sendMessage(event, clientId, data) {
        const ws = this.idToWs.get(clientId);
        //  TODO: throw a nice error
        if (!ws)
            return;
        const packet = {
            event,
            data
        };
        const serializedPacket = serialize(packet);
        //  TODO: throw a nice error
        if (!serializedPacket)
            return;
        ws.send(serializedPacket);
    }
    broadcastRaw(data) {
        const serializedData = serialize(data);
        if (!serializedData) {
            //  TODO: throw a nice error
            return;
        }
        this.idToWs.forEach((ws) => {
            ws.send(serializedData);
        });
    }
    broadcast(event, data) {
        const packet = {
            event,
            data
        };
        const serializedPacket = serialize(packet);
        if (!serializedPacket)
            return;
        this.idToWs.forEach((ws) => {
            ws.send(serializedPacket);
        });
    }
    selectiveBroascast(event, data, connections) {
        const serialized = serialize(data);
        if (!serialized) {
            //  TODO: throw a nice error
            return;
        }
        const packet = {
            event,
            data
        };
        const serializedPacket = serialize(packet); // if data is serializable then packet is too, so no need to check
        connections
            .flatMap(x => this.idToWs.get(x) ?? [])
            .forEach((ws) => {
            ws.send(serializedPacket);
        });
    }
    get events() {
        return Object.fromEntries(Object.keys(this._events).map((eventName) => {
            return [
                eventName,
                {
                    send: (clientId, data) => {
                        const packet = {
                            event: eventName,
                            data
                        };
                        this.sendMessageRaw(clientId, packet);
                    },
                    broadcast: (data) => {
                        const packet = {
                            event: eventName,
                            data
                        };
                        this.broadcastRaw(packet);
                    }
                }
            ];
        }));
    }
    get clients() {
        return this.idToWs.keys().toArray();
    }
    get socketMap() {
        return this.idToWs;
    }
}
export const createZapServer = ({ port, events, cors, options }, callback) => {
    const server = new ZapServer({ port, events, cors, options }, callback);
    return server;
};
